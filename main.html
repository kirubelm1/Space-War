<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <title>ROGUE SECTOR ‚Äî One File 2D Game</title>
    <style>
        :root {
            --bg: #070b12;
            --ink: #e7f0ff;
            --cyan: #67e8f9;
            --vio: #a78bfa;
            --mag: #f472b6;
            --yel: #fde047;
            --red: #fb7185;
            --grn: #34d399;
            --muted: #0f1522;
        }
        * { box-sizing: border-box; }
        html, body { height: 100%; margin: 0; background: radial-gradient(1200px 800px at 50% 105%, #0d1730 0%, var(--bg) 60%); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
        #wrap { display: flex; align-items: center; justify-content: center; height: 100%; padding: 12px; }
        canvas { background: linear-gradient(180deg, rgba(8,12,20,0.6), rgba(6,10,16,0.92)), radial-gradient(1000px 600px at 50% 110%, #0a1220, #080c15); box-shadow: 0 10px 40px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.05); border-radius: 18px; display: block; max-width: 100%; height: auto; }
        #hud { position: absolute; inset: 0; pointer-events: none; }
        .row { position: absolute; left: 50%; transform: translateX(-50%); display: flex; gap: 10px; align-items: center; justify-content: center; }
        #top { top: 14px; }
        #bottom { bottom: 14px; }
        .pill { pointer-events: auto; user-select: none; background: rgba(255,255,255,.06); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.08); padding: 8px 12px; border-radius: 999px; display: inline-flex; gap: 8px; align-items: center; transition: background 0.2s, transform 0.2s; }
        .pill:hover { background: rgba(255,255,255,.12); transform: scale(1.05); }
        .btn { pointer-events: auto; display: inline-flex; align-items: center; justify-content: center; width: 46px; height: 46px; border-radius: 50%; border: 1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); box-shadow: inset 0 0 10px rgba(255,255,255,.06); transition: background 0.2s, transform 0.1s; }
        .btn:hover { background: rgba(255,255,255,.12); }
        .btn:active { transform: translateY(2px); }
        .meter { height: 10px; width: 140px; border-radius: 999px; background: rgba(255,255,255,.08); overflow: hidden; border: 1px solid rgba(255,255,255,.12); }
        .fill { height: 100%; width: 0; background: linear-gradient(90deg, var(--vio), var(--cyan)); transition: width 0.2s ease-out; }
        #title { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -57%); text-align: center; max-width: 88vw; transition: opacity 0.5s; }
        h1 { font-weight: 800; margin: 0 0 10px 0; letter-spacing: .5px; font-size: clamp(22px, 6vw, 44px); text-shadow: 0 0 10px var(--cyan); }
        .subtitle { opacity: .85; margin-bottom: 14px; }
        kbd { font-family: ui-monospace, Menlo, Consolas, monospace; background: rgba(255,255,255,.08); padding: 2px 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,.12); }
        #startBtn { pointer-events: auto; display: inline-block; margin-top: 10px; padding: 10px 16px; border-radius: 12px; border: 1px solid rgba(255,255,255,.12); background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03)); cursor: pointer; transition: background 0.2s, transform 0.1s; box-shadow: 0 0 15px rgba(103,232,249,0.5); }
        #startBtn:hover { background: linear-gradient(180deg, rgba(255,255,255,.15), rgba(255,255,255,.06)); transform: scale(1.05); }
        #startBtn:active { transform: translateY(2px); }
        #small { position: absolute; left: 50%; bottom: 6px; transform: translateX(-50%); opacity: .6; font-size: 12px; }
        .hidden { display: none; }
        /* Virtual sticks */
        .stick { position: absolute; bottom: 84px; width: 160px; height: 160px; border-radius: 50%; background: radial-gradient(closest-side, rgba(255,255,255,.08), rgba(255,255,255,0)); border: 1px solid rgba(255,255,255,.12); pointer-events: auto; overflow: hidden; transition: box-shadow 0.2s; }
        .stick:hover { box-shadow: 0 0 10px rgba(103,232,249,0.3); }
        .stick::after { content: ''; position: absolute; width: 60px; height: 60px; border-radius: 50%; background: rgba(255,255,255,.15); left: 50%; top: 50%; transform: translate(-50%, -50%); transition: transform 0.1s; }
        #stickL { left: 24px; }
        #stickR { right: 24px; }
        #stickL.active::after { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))); }
        #stickR.active::after { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))); }
    </style>
</head>
<body>
    <div id="wrap">
        <canvas id="game" width="1024" height="576"></canvas>
        <div id="hud">
            <div id="top" class="row">
                <span class="pill"><b>Score:</b>&nbsp;<span id="score">0</span></span>
                <span class="pill"><b>Best:</b>&nbsp;<span id="best">0</span></span>
                <span class="pill"><b>Wave:</b>&nbsp;<span id="wave">1</span></span>
                <span class="pill"><b>HP:</b>&nbsp;<span id="hp">100</span></span>
                <span class="pill"><b>Combo:</b>&nbsp;<span id="combo">0</span></span>
                <span class="pill"><b>FPS:</b>&nbsp;<span id="fps">0</span></span>
                <span class="pill"><b>Vol:</b>&nbsp;<span id="vol">ON</span></span>
                <span class="pill meter" title="Dash energy"><span id="dashFill" class="fill"></span></span>
            </div>
            <div id="bottom" class="row">
                <button class="btn" id="dash" aria-label="Dash">‚ö°</button>
                <button class="btn" id="bomb" aria-label="Pulse Bomb">üí£</button>
                <button class="btn" id="pause" aria-label="Pause">‚è∏</button>
                <button class="btn" id="mute" aria-label="Mute">üîä</button>
            </div>
            <div id="title">
                <h1>ROGUE SECTOR ‚öîÔ∏è</h1>
                <div class="subtitle">Twin‚Äëstick arena shooter with <b>waves</b>, <b>upgrades</b>, <b>dash</b>, <b>pulse bomb</b>, and juicy particles. Now with homing bullets, dasher enemies, starfield, glow effects, and more!</div>
                <div>
                    <span class="pill">Move: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></span>
                    <span class="pill">Aim: <kbd>Mouse</kbd></span>
                    <span class="pill">Shoot: <kbd>Left Click</kbd> / Hold</span>
                    <span class="pill">Dash: <kbd>Shift</kbd></span>
                    <span class="pill">Bomb: <kbd>E</kbd></span>
                    <span class="pill">Pause: <kbd>P</kbd></span>
                    <div style="margin-top:8px;opacity:.8">Mobile: left/right virtual sticks + buttons</div>
                </div>
                <button id="startBtn">Start Game</button>
            </div>
            <div id="small">One-file HTML/CSS/JS ‚Ä¢ Desktop + touch ‚Ä¢ No external assets ‚Ä¢ Enhanced Edition</div>
            <div id="stickL" class="stick"></div>
            <div id="stickR" class="stick"></div>
        </div>
    </div>
    <script>
        // === ROGUE SECTOR ‚Äî single-file 2D top-down shooter ===
        // Features: twin-stick (mouse + touch sticks), waves & scaling difficulty, dash with energy, pulse bomb, upgrades drops,
        // chaser/shooter/splitter enemies, particles, screen shake, WebAudio beeps, pause, high score.
        // Enhanced: homing upgrade, dasher enemy, starfield background, bullet glow trails, screen flash, wave announce, combo float text.

        (function(){
            const canvas = document.getElementById('game');
            const ctx = canvas.getContext('2d');
            const W = canvas.width, H = canvas.height;

            // --- UI ---
            const ui = {
                score: document.getElementById('score'),
                best: document.getElementById('best'),
                wave: document.getElementById('wave'),
                hp: document.getElementById('hp'),
                combo: document.getElementById('combo'),
                fps: document.getElementById('fps'),
                vol: document.getElementById('vol'),
                dashFill: document.getElementById('dashFill'),
                title: document.getElementById('title'),
                start: document.getElementById('startBtn'),
                dashBtn: document.getElementById('dash'),
                bombBtn: document.getElementById('bomb'),
                pauseBtn: document.getElementById('pause'),
                muteBtn: document.getElementById('mute'),
                stickL: document.getElementById('stickL'),
                stickR: document.getElementById('stickR'),
            };
            let bestScore = +localStorage.getItem('rogue_best') || 0;
            ui.best.textContent = bestScore;

            // --- Audio ---
            let audioCtx = null, muted = false;
            function initAudio() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioCtx.resume(); // Ensure audio context is resumed
                }
            }
            function beep(type = 'sine', f = 440, dur = 0.06, g = 0.15) {
                if (muted || !audioCtx) return;
                const o = audioCtx.createOscillator(), ga = audioCtx.createGain();
                o.type = type;
                o.frequency.setValueAtTime(f, audioCtx.currentTime);
                ga.gain.value = 0;
                o.connect(ga);
                ga.connect(audioCtx.destination);
                const t = audioCtx.currentTime;
                ga.gain.linearRampToValueAtTime(g, t + 0.005);
                ga.gain.exponentialRampToValueAtTime(0.0001, t + dur);
                o.start(t);
                o.stop(t + dur);
            }

            // --- Math/Util ---
            const RNG = (seed => () => (seed = (seed * 1664525 + 1013904223) | 0, (seed >>> 0) / 4294967296))((Date.now() ^ 1234567) | 0);
            const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
            const lerp = (a, b, t) => a + (b - a) * t;
            const rand = (a, b) => a + RNG() * (b - a);
            const TAU = Math.PI * 2;
            function angle(x1, y1, x2, y2) { return Math.atan2(y2 - y1, x2 - x1); }
            function len(x, y) { return Math.hypot(x, y); }
            function norm(x, y) { const L = len(x, y) || 1; return { x: x / L, y: y / L }; }
            function circleHit(ax, ay, ar, bx, by, br) { return len(ax - bx, ay - by) < ar + br; }

            // --- Input (keyboard/mouse) ---
            let keys = {};
            let mouse = { x: W / 2, y: H / 2, down: false };
            window.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key)) e.preventDefault();
                if (e.key === 'm' || e.key === 'M') { muted = !muted; ui.vol.textContent = muted ? 'OFF' : 'ON'; beep('square', 220, 0.05, 0.12); }
                if (e.key === 'p' || e.key === 'P') { if (!running) return; paused = !paused; if (!paused) last = performance.now(); beep('sine', paused ? 220 : 660, 0.06, 0.2); }
                if (e.key === 'e' || e.key === 'E') wantBomb = true;
                if (e.key === 'shift') wantDash = true;
            });
            window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('pointermove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = (e.clientX - rect.left) / (rect.width) * W;
                mouse.y = (e.clientY - rect.top) / (rect.height) * H;
            });
            canvas.addEventListener('pointerdown', e => {
                const rect = canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) / rect.width * W;
                const my = (e.clientY - rect.top) / rect.height * H;
                mouse.down = true;
                initAudio();
                if (upgradeState) {
                    const btnW = 200, btnH = 60;
                    const spacing = 1.1;
                    const startX = W / 2 - (btnW * 3 * spacing - btnW * (spacing - 1)) / 2;
                    const startY = H / 2 - btnH / 2;
                    for (let i = 0; i < 3; i++) {
                        const bx = startX + i * btnW * spacing;
                        const by = startY;
                        if (mx > bx && mx < bx + btnW && my > by && my < by + btnH) {
                            const t = upgradeOptions[i];
                            applyUpgrade(t);
                            upgradeState = false;
                            spawnWave();
                            beep('triangle', 800, 0.08, 0.22);
                            break;
                        }
                    }
                }
            });
            canvas.addEventListener('pointerup', () => mouse.down = false);

            // --- Touch virtual sticks ---
            const sticks = {
                L: { id: null, ox: 0, oy: 0, dx: 0, dy: 0, active: false },
                R: { id: null, ox: 0, oy: 0, dx: 0, dy: 0, active: false }
            };
            function setupStick(el, key) {
                el.addEventListener('pointerdown', e => {
                    e.preventDefault();
                    el.setPointerCapture(e.pointerId);
                    const r = el.getBoundingClientRect();
                    sticks[key].id = e.pointerId;
                    sticks[key].ox = (e.clientX - r.left) / r.width;
                    sticks[key].oy = (e.clientY - r.top) / r.height;
                    sticks[key].dx = 0;
                    sticks[key].dy = 0;
                    sticks[key].active = true;
                    el.classList.add('active');
                    el.style.setProperty('--dx', `${sticks[key].dx * 50}px`);
                    el.style.setProperty('--dy', `${sticks[key].dy * 50}px`);
                    initAudio();
                });
                el.addEventListener('pointermove', e => {
                    if (sticks[key].id !== e.pointerId) return;
                    const r = el.getBoundingClientRect();
                    const x = (e.clientX - r.left) / r.width, y = (e.clientY - r.top) / r.height;
                    sticks[key].dx = clamp((x - sticks[key].ox) * 2, -1, 1);
                    sticks[key].dy = clamp((y - sticks[key].oy) * 2, -1, 1);
                    el.style.setProperty('--dx', `${sticks[key].dx * 50}px`);
                    el.style.setProperty('--dy', `${sticks[key].dy * 50}px`);
                });
                const end = () => {
                    sticks[key].id = null;
                    sticks[key].dx = sticks[key].dy = 0;
                    sticks[key].active = false;
                    el.classList.remove('active');
                    el.style.setProperty('--dx', '0px');
                    el.style.setProperty('--dy', '0px');
                };
                el.addEventListener('pointerup', end);
                el.addEventListener('pointercancel', end);
                el.addEventListener('pointerleave', end);
            }
            setupStick(ui.stickL, 'L');
            setupStick(ui.stickR, 'R');
            ui.dashBtn.addEventListener('click', () => { wantDash = true; initAudio(); });
            ui.bombBtn.addEventListener('click', () => { wantBomb = true; initAudio(); });
            ui.pauseBtn.addEventListener('click', () => { if (!running) return; paused = !paused; if (!paused) last = performance.now(); beep('sine', paused ? 220 : 660, 0.06, 0.2); });
            ui.muteBtn.addEventListener('click', () => { muted = !muted; ui.vol.textContent = muted ? 'OFF' : 'ON'; beep('square', 220, 0.05, 0.12); });

            // --- Game state ---
            let running = false, paused = false, gameOver = false;
            let last = performance.now();
            let score = 0, wave = 1, combo = 0, comboTimer = 0;
            let fps = 0, fpsAccum = 0, fpsFrames = 0;
            let wantDash = false, wantBomb = false, shake = 0;
            let waveDelay = 0;
            let upgradeState = false;
            let upgradeOptions = [];
            let waveAnnounce = 0;
            let flash = 0;
            let comboShow = 0, comboX = 0, comboY = 0;
            const upgradeNames = {
                heal: 'Full Heal',
                rate: 'Fire Rate ++',
                dmg: 'Damage ++',
                speed: 'Speed ++',
                shield: 'Max HP ++',
                multi: 'Multi Shot',
                pierce: 'Pierce ++',
                homing: 'Homing Bullets'
            };
            const player = {
                x: W / 2, y: H / 2, r: 16, ax: 0, ay: 0, vx: 0, vy: 0, speed: 260,
                aim: 0, hp: 100, maxhp: 100, fireCD: 0, fireRate: 8, bulletSpeed: 560,
                damage: 10, dashCD: 0, dashEnergy: 1, bombCD: 0, inv: 0, alive: true,
                multi: 0, pierce: 0, homing: false
            };
            const bullets = [], ebullets = [], enemies = [], pickups = [], particles = [];
            let stars = [];

            // --- Spawning ---
            function spawnEnemy() {
                if (enemies.length > 50) return;
                const typeProb = RNG();
                let type;
                if (typeProb < 0.3) type = 'chaser';
                else if (typeProb < 0.55) type = 'shooter';
                else if (typeProb < 0.7) type = 'splitter';
                else if (typeProb < 0.8) type = 'tank';
                else if (typeProb < 0.9) type = 'bomber';
                else type = 'dasher';
                const margin = 60;
                const side = (RNG() * 4) | 0;
                let x, y;
                if (side === 0) { x = -margin; y = rand(0, H); }
                else if (side === 1) { x = W + margin; y = rand(0, H); }
                else if (side === 2) { x = rand(0, W); y = -margin; }
                else { x = rand(0, W); y = H + margin; }
                if (type === 'chaser') enemies.push({ type, x, y, r: 14, hp: 20 + wave * 2, t: 0, speed: 100 + wave * 3, scale: 1 });
                else if (type === 'shooter') enemies.push({ type, x, y, r: 16, hp: 30 + wave * 3, t: 0, speed: 80 + wave * 2, cd: rand(0.6, 1.3), scale: 1 });
                else if (type === 'splitter') enemies.push({ type, x, y, r: 12, hp: 18 + wave * 1.5, t: 0, speed: 120 + wave * 4, scale: 1 });
                else if (type === 'tank') enemies.push({ type, x, y, r: 20, hp: 50 + wave * 4, t: 0, speed: 60 + wave * 2, cd: rand(0.8, 1.4), scale: 1 });
                else if (type === 'bomber') enemies.push({ type, x, y, r: 15, hp: 25 + wave * 2.5, t: 0, speed: 110 + wave * 3, scale: 1 });
                else if (type === 'dasher') enemies.push({ type, x, y, r: 13, hp: 22 + wave * 2.2, t: 0, speed: 90 + wave * 3, cd: rand(1.5, 2.5), dashT: 0, scale: 1 });
            }
            function spawnBoss() {
                const margin = 60;
                const side = (RNG() * 4) | 0;
                let x, y;
                if (side === 0) { x = -margin; y = rand(0, H); }
                else if (side === 1) { x = W + margin; y = rand(0, H); }
                else if (side === 2) { x = rand(0, W); y = -margin; }
                else { x = rand(0, W); y = H + margin; }
                enemies.push({ type: 'boss', x, y, r: 32, hp: 200 + wave * 10, t: 0, speed: 70 + wave * 2, cd: 0.5, scale: 1 });
            }
            function spawnWave() {
                const toSpawn = 3 + Math.floor(wave / 2);
                for (let i = 0; i < toSpawn; i++) spawnEnemy();
                if (wave % 5 === 0) spawnBoss(); // Changed to every 5 waves for more challenge
                waveAnnounce = 1.5;
            }
            function generateUpgradeOptions() {
                const types = ['heal', 'rate', 'dmg', 'speed', 'shield', 'multi', 'pierce', 'homing'];
                upgradeOptions = [];
                for (let i = 0; i < 3; i++) {
                    const idx = Math.floor(RNG() * types.length);
                    upgradeOptions.push(types.splice(idx, 1)[0]);
                }
            }
            function applyUpgrade(t) {
                if (t === 'heal') { player.hp = player.maxhp; }
                if (t === 'rate') { player.fireRate += 1.2; }
                if (t === 'dmg') { player.damage += 4; }
                if (t === 'speed') { player.speed += 20; }
                if (t === 'shield') { player.maxhp += 20; player.hp += 20; }
                if (t === 'multi') { player.multi += 1; }
                if (t === 'pierce') { player.pierce += 2; }
                if (t === 'homing') { player.homing = true; }
                ui.hp.textContent = Math.round(player.hp);
                pickupSound();
            }
            function spawnPickup(x, y) {
                const types = ['heal', 'rate', 'dmg', 'speed', 'shield', 'multi', 'pierce', 'homing'];
                const t = types[(RNG() * types.length) | 0];
                pickups.push({ x, y, r: 10, t, life: 10 });
            }

            function startGame() {
                running = true;
                paused = false;
                gameOver = false;
                score = 0;
                wave = 1;
                combo = 0;
                comboTimer = 0;
                shake = 0;
                waveDelay = 0;
                upgradeState = false;
                upgradeOptions = [];
                waveAnnounce = 0;
                flash = 0;
                comboShow = 0;
                stars = [];
                for (let i = 0; i < 150; i++) { // More stars for better effect
                    stars.push({
                        x: rand(0, W),
                        y: rand(0, H),
                        size: rand(0.5, 2.5),
                        speed: rand(30, 80),
                        alpha: rand(0.3, 0.7)
                    });
                }
                Object.assign(player, {
                    x: W / 2, y: H / 2, vx: 0, vy: 0, ax: 0, ay: 0, aim: 0,
                    hp: 100, maxhp: 100, fireCD: 0, fireRate: 8, bulletSpeed: 560,
                    damage: 10, dashCD: 0, dashEnergy: 1, bombCD: 0, inv: 0, alive: true,
                    speed: 260, multi: 0, pierce: 0, homing: false
                });
                bullets.length = 0;
                ebullets.length = 0;
                enemies.length = 0;
                pickups.length = 0;
                particles.length = 0;
                ui.title.classList.add('hidden');
                ui.wave.textContent = 1;
                ui.hp.textContent = 100;
                ui.combo.textContent = 0;
                ui.score.textContent = 0;
                last = performance.now();
                initAudio();
                beep('triangle', 660, 0.09, 0.25);
                spawnWave();
            }
            ui.start.addEventListener('click', startGame, { once: false });

            // --- Loop ---
            function loop(now) {
                if (!running) {
                    draw(0);
                    requestAnimationFrame(loop);
                    return;
                }
                const rawDt = (now - last) / 1000;
                last = now;
                fpsAccum += rawDt;
                fpsFrames++;
                if (fpsAccum > 0.5) {
                    fps = Math.round(fpsFrames / fpsAccum);
                    ui.fps.textContent = fps;
                    fpsAccum = 0;
                    fpsFrames = 0;
                }
                if (paused) {
                    draw(0);
                    requestAnimationFrame(loop);
                    return;
                }
                const dt = Math.min(0.033, rawDt);
                update(dt);
                draw(dt);
                requestAnimationFrame(loop);
            }

            // --- FX ---
            function spawnPart(x, y, dx, dy, life, size, col, a = 1) {
                if (particles.length > 300) return; // Increased cap
                particles.push({ x, y, dx, dy, life, size, col, a });
            }
            function burst(x, y, n, col, spd = 180) {
                for (let i = 0; i < n; i++) {
                    const ang = RNG() * TAU;
                    const sp = spd * rand(0.4, 1.2);
                    spawnPart(x, y, Math.cos(ang) * sp, Math.sin(ang) * sp, rand(0.3, 0.7), rand(2, 3), col, 1);
                }
            }
            function doDamageSound() { beep('sawtooth', 140, 0.08, 0.25); }
            function shootSound() { beep('square', 500, 0.04, 0.12); }
            function pickupSound() { beep('triangle', 680, 0.07, 0.18); }
            function bombSound() { beep('sawtooth', 300, 0.12, 0.28); }
            function dashSound() { beep('square', 520, 0.05, 0.18); }
            function comboSound() { beep('triangle', 880, 0.08, 0.2); }

            // --- Update ---
            function update(dt) {
                if (upgradeState) return;

                // Combo timer
                comboTimer = Math.max(0, comboTimer - dt);
                if (comboTimer <= 0) {
                    combo = 0;
                    ui.combo.textContent = combo;
                }

                // Wave progression
                if (enemies.length === 0) {
                    waveDelay += dt;
                    if (waveDelay > 1.5) {
                        waveDelay = 0;
                        wave++;
                        ui.wave.textContent = wave;
                        if (wave % 5 === 0) {
                            upgradeState = true;
                            generateUpgradeOptions();
                        } else {
                            spawnWave();
                        }
                    }
                } else {
                    waveDelay = 0;
                }

                // Input axes
                let mx = 0, my = 0;
                if (keys['w']) my -= 1;
                if (keys['s']) my += 1;
                if (keys['a']) mx -= 1;
                if (keys['d']) mx += 1;
                if (sticks.L.active) {
                    mx += sticks.L.dx;
                    my += sticks.L.dy;
                }
                const mlen = len(mx, my);
                if (mlen > 1) {
                    mx /= mlen;
                    my /= mlen;
                } // Normalize combined input

                // Aim
                let aimX = Math.cos(player.aim), aimY = Math.sin(player.aim);
                if (sticks.R.active) {
                    aimX = sticks.R.dx;
                    aimY = sticks.R.dy;
                } else {
                    player.aim = angle(player.x, player.y, mouse.x, mouse.y);
                    aimX = Math.cos(player.aim);
                    aimY = Math.sin(player.aim);
                }

                // Movement
                const accel = 1200;
                player.vx = lerp(player.vx, mx * player.speed, 0.18);
                player.vy = lerp(player.vy, my * player.speed, 0.18);
                player.x += player.vx * dt;
                player.y += player.vy * dt;
                player.x = clamp(player.x, 20, W - 20);
                player.y = clamp(player.y, 20, H - 20);

                // Fire
                player.fireCD = Math.max(0, player.fireCD - dt);
                const firing = mouse.down || sticks.R.active;
                if (firing && player.fireCD === 0) {
                    const baseSpread = 0.05;
                    const numShots = 1 + player.multi * 2;
                    const shotSpread = 0.15;
                    for (let k = -(numShots - 1) / 2; k <= (numShots - 1) / 2; k++) {
                        const a = player.aim + rand(-baseSpread, baseSpread) + k * shotSpread;
                        const sp = player.bulletSpeed;
                        bullets.push({ x: player.x + Math.cos(a) * 18, y: player.y + Math.sin(a) * 18, dx: Math.cos(a) * sp, dy: Math.sin(a) * sp, r: 4, life: 1.2, dmg: player.damage, pierce: player.pierce });
                        burst(player.x + Math.cos(a) * 12, player.y + Math.sin(a) * 12, 5, 'rgba(103,232,249,0.9)', 140);
                    }
                    player.fireCD = 1 / player.fireRate;
                    shootSound();
                }

                // Dash
                player.dashCD = Math.max(0, player.dashCD - dt);
                player.dashEnergy = clamp(player.dashEnergy + dt * 0.3, 0, 1);
                ui.dashFill.style.width = (player.dashEnergy * 100) + '%';
                if (wantDash && player.dashCD === 0 && player.dashEnergy > 0.3) {
                    const dir = norm(player.vx || aimX, player.vy || aimY);
                    player.x += dir.x * 120;
                    player.y += dir.y * 120;
                    player.dashCD = 0.6;
                    player.dashEnergy = Math.max(0, player.dashEnergy - 0.35);
                    burst(player.x, player.y, 20, 'rgba(103,232,249,0.95)', 260);
                    dashSound();
                    shake = 12;
                }
                wantDash = false;

                // Bomb
                player.bombCD = Math.max(0, player.bombCD - dt);
                if (wantBomb && player.bombCD === 0) {
                    player.bombCD = 5;
                    for (let i = 0; i < 48; i++) {
                        const ang = i / 48 * TAU;
                        bullets.push({ x: player.x, y: player.y, dx: Math.cos(ang) * 340, dy: Math.sin(ang) * 340, r: 4, life: 0.8, dmg: player.damage * 0.5, pierce: player.pierce });
                    }
                    burst(player.x, player.y, 45, 'rgba(247,114,181,0.95)', 220);
                    bombSound();
                    shake = 14;
                }
                wantBomb = false;

                // Timers
                player.inv = Math.max(0, player.inv - dt);
                waveAnnounce = Math.max(0, waveAnnounce - dt);
                flash = Math.max(0, flash - dt * 3);
                comboShow = Math.max(0, comboShow - dt);

                // Update bullets
                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    if (player.homing) {
                        let closest = null, minD = Infinity;
                        for (let e of enemies) {
                            let d = len(b.x - e.x, b.y - e.y);
                            if (d < minD) { minD = d; closest = e; }
                        }
                        if (closest && minD < 300) {
                            let ang = angle(b.x, b.y, closest.x, closest.y);
                            let curAng = angle(0, 0, b.dx, b.dy);
                            let diff = ang - curAng;
                            if (diff > Math.PI) diff -= TAU;
                            if (diff < -Math.PI) diff += TAU;
                            let steer = clamp(diff, -0.1, 0.1);
                            let newAng = curAng + steer;
                            let sp = len(b.dx, b.dy);
                            b.dx = Math.cos(newAng) * sp;
                            b.dy = Math.sin(newAng) * sp;
                        }
                    }
                    b.x += b.dx * dt;
                    b.y += b.dy * dt;
                    b.life -= dt;
                    if (b.life <= 0 || b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) bullets.splice(i, 1);
                }
                for (let i = ebullets.length - 1; i >= 0; i--) {
                    const b = ebullets[i];
                    b.x += b.dx * dt;
                    b.y += b.dy * dt;
                    b.life -= dt;
                    if (b.life <= 0 || b.x < -20 || b.x > W + 20 || b.y < -20 || b.y > H + 20) ebullets.splice(i, 1);
                    if (circleHit(player.x, player.y, player.r, b.x, b.y, b.r)) {
                        if (player.inv <= 0) {
                            player.hp -= 6;
                            ui.hp.textContent = Math.max(0, Math.round(player.hp));
                            player.inv = 0.6;
                            doDamageSound();
                            shake = 10;
                            flash = 0.15;
                            burst(player.x, player.y, 12, 'rgba(251,113,133,0.95)', 180);
                        }
                        ebullets.splice(i, 1);
                    }
                }

                // Enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const e = enemies[i];
                    e.t += dt;
                    e.scale = lerp(e.scale, 1, 0.1); // Smooth scale back to 1
                    const ang = angle(e.x, e.y, player.x, player.y);
                    let currSpeed = e.speed;
                    // Behaviors
                    if (e.type === 'shooter') {
                        e.cd -= dt;
                        if (e.cd <= 0) {
                            e.cd = rand(1.2, 1.9);
                            const a = angle(e.x, e.y, player.x, player.y) + rand(-0.1, 0.1);
                            ebullets.push({ x: e.x + Math.cos(a) * 12, y: e.y + Math.sin(a) * 12, dx: Math.cos(a) * 300, dy: Math.sin(a) * 300, r: 4, life: 2 });
                            beep('sine', 400, 0.03, 0.12);
                        }
                    } else if (e.type === 'tank') {
                        e.cd -= dt;
                        if (e.cd <= 0) {
                            e.cd = rand(1.5, 2.2);
                            const a = angle(e.x, e.y, player.x, player.y);
                            for (let k = -1; k <= 1; k++) {
                                const aa = a + k * 0.2;
                                ebullets.push({ x: e.x + Math.cos(aa) * 15, y: e.y + Math.sin(aa) * 15, dx: Math.cos(aa) * 250, dy: Math.sin(aa) * 250, r: 5, life: 2.5 });
                            }
                            beep('sine', 350, 0.04, 0.15);
                        }
                    } else if (e.type === 'boss') {
                        e.cd -= dt;
                        if (e.cd <= 0) {
                            e.cd = 1.0;
                            const a = angle(e.x, e.y, player.x, player.y) + e.t * 2; // Rotating spiral
                            for (let k = 0; k < 8; k++) {
                                const aa = a + k * TAU / 8;
                                ebullets.push({ x: e.x + Math.cos(aa) * 20, y: e.y + Math.sin(aa) * 20, dx: Math.cos(aa) * 200, dy: Math.sin(aa) * 200, r: 6, life: 3 });
                            }
                            beep('sawtooth', 200, 0.05, 0.18);
                        }
                    } else if (e.type === 'dasher') {
                        e.cd -= dt;
                        e.dashT = Math.max(0, e.dashT - dt);
                        if (e.cd <= 0) {
                            e.dashT = 0.3;
                            e.cd = rand(1.8, 2.8);
                        }
                        if (e.dashT > 0) {
                            currSpeed *= 3;
                            burst(e.x, e.y, 3, 'rgba(236,72,153,0.8)', 100);
                        }
                    }
                    e.x += Math.cos(ang) * currSpeed * dt;
                    e.y += Math.sin(ang) * currSpeed * dt;

                    // Collide with player
                    if (circleHit(player.x, player.y, player.r, e.x, e.y, e.r)) {
                        if (player.inv <= 0) {
                            player.hp -= 10;
                            ui.hp.textContent = Math.max(0, Math.round(player.hp));
                            player.inv = 0.6;
                            doDamageSound();
                            shake = 12;
                            flash = 0.15;
                            burst(player.x, player.y, 14, 'rgba(251,113,133,0.95)', 220);
                        }
                        const push = norm(player.x - e.x, player.y - e.y);
                        player.x += push.x * 10;
                        player.y += push.y * 10;
                    }

                    // Hit by bullets
                    for (let j = bullets.length - 1; j >= 0; j--) {
                        const b = bullets[j];
                        if (circleHit(e.x, e.y, e.r, b.x, b.y, b.r)) {
                            e.hp -= b.dmg;
                            e.scale = 1.2; // Scale up on hit
                            burst(b.x, b.y, 8, 'rgba(167,139,250,0.95)', 160);
                            flash = 0.1;
                            if (b.pierce > 0) {
                                b.pierce--;
                            } else {
                                bullets.splice(j, 1);
                            }
                            if (e.hp <= 0) {
                                combo++;
                                comboTimer = 3;
                                if (combo > 1) comboSound();
                                ui.combo.textContent = combo;
                                comboShow = 1.2;
                                comboX = e.x;
                                comboY = e.y;
                                const baseScore = (e.type === 'boss' ? 100 : 10) + Math.floor(wave * 0.5);
                                score += baseScore * combo;
                                ui.score.textContent = Math.floor(score);
                                if (RNG() < 0.35) spawnPickup(e.x, e.y);
                                if (e.type === 'splitter') {
                                    for (let k = 0; k < 3; k++) {
                                        enemies.push({ type: 'chaser', x: e.x + rand(-8, 8), y: e.y + rand(-8, 8), r: 10, hp: 14 + wave * 1.5, t: 0, speed: 130 + wave * 5, scale: 1 });
                                    }
                                }
                                if (e.type === 'bomber') {
                                    for (let k = 0; k < 12; k++) {
                                        const ang = k / 12 * TAU;
                                        const sp = 240;
                                        ebullets.push({ x: e.x, y: e.y, dx: Math.cos(ang) * sp, dy: Math.sin(ang) * sp, r: 5, life: 1.2 });
                                    }
                                    burst(e.x, e.y, 35, 'rgba(253,224,71,0.95)', 280);
                                    beep('sawtooth', 120, 0.1, 0.25);
                                }
                                burst(e.x, e.y, 28, 'rgba(103,232,249,0.95)', 220);
                                beep('sawtooth', 180, 0.06, 0.22);
                                enemies.splice(i, 1);
                                break;
                            }
                        }
                    }
                }

                // Pickups
                for (let i = pickups.length - 1; i >= 0; i--) {
                    const p = pickups[i];
                    p.life -= dt;
                    if (p.life <= 0) {
                        pickups.splice(i, 1);
                        continue;
                    }
                    if (circleHit(player.x, player.y, player.r, p.x, p.y, p.r)) {
                        if (p.t === 'heal') { player.hp = Math.min(player.maxhp, player.hp + 25); }
                        if (p.t === 'rate') { player.fireRate += 0.7; }
                        if (p.t === 'dmg') { player.damage += 2.5; }
                        if (p.t === 'speed') { player.speed += 12; }
                        if (p.t === 'shield') { player.inv = 1.2; }
                        if (p.t === 'multi') { player.multi += 1; }
                        if (p.t === 'pierce') { player.pierce += 1; }
                        if (p.t === 'homing') { player.homing = true; }
                        ui.hp.textContent = Math.round(player.hp);
                        pickupSound();
                        burst(p.x, p.y, 20, 'rgba(253,224,71,0.95)', 220);
                        pickups.splice(i, 1);
                    }
                }

                // Background stars
                for (const s of stars) {
                    s.y += s.speed * dt;
                    if (s.y > H) s.y -= H;
                }

                // Player death
                if (player.hp <= 0) {
                    die();
                }

                // Best score save
                if (score > bestScore) {
                    bestScore = Math.floor(score);
                    ui.best.textContent = bestScore;
                    localStorage.setItem('rogue_best', bestScore);
                }

                // Screen shake timer
                shake = Math.max(0, shake - dt * 30);
            }

            function die() {
                if (gameOver) return;
                gameOver = true;
                running = false;
                upgradeState = false;
                for (let i = 0; i < 50; i++) {
                    const ang = RNG() * TAU;
                    const sp = rand(120, 260);
                    spawnPart(player.x, player.y, Math.cos(ang) * sp, Math.sin(ang) * sp, rand(0.4, 0.9), rand(2, 3), 'rgba(251,113,133,0.95)', 1);
                }
                doDamageSound();
                setTimeout(() => {
                    ui.title.classList.remove('hidden');
                    ui.start.textContent = 'Restart';
                }, 450);
            }

            // --- Draw ---
            function draw(dt) {
                // Clear + shake
                const sx = shake ? (Math.random() - 0.5) * shake : 0;
                const sy = shake ? (Math.random() - 0.5) * shake : 0;
                ctx.setTransform(1, 0, 0, 1, sx, sy);
                ctx.clearRect(-sx, -sy, W, H);

                // Background stars
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                for (const s of stars) {
                    ctx.globalAlpha = s.alpha;
                    ctx.moveTo(s.x, s.y);
                    ctx.arc(s.x, s.y, s.size / 2, 0, TAU);
                }
                ctx.fill();
                ctx.globalAlpha = 1;

                // Grid background
                drawGrid();

                // Particles
                ctx.globalAlpha = 1;
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.dx * (dt || 0);
                    p.y += p.dy * (dt || 0);
                    p.life -= dt || 0;
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }
                    glow(p.x, p.y, p.size * 3, p.col, Math.max(0.15, p.life * 1.2));
                }
                ctx.globalAlpha = 1;

                // Player
                drawPlayer();

                // Bullets with glow
                for (const b of bullets) {
                    glow(b.x, b.y, 12, 'rgba(103,232,249,0.5)');
                }
                ctx.fillStyle = '#9cc1ff';
                ctx.beginPath();
                for (const b of bullets) {
                    ctx.moveTo(b.x, b.y);
                    ctx.arc(b.x, b.y, b.r, 0, TAU);
                }
                ctx.fill();

                for (const b of ebullets) {
                    glow(b.x, b.y, 12, 'rgba(251,113,133,0.5)');
                }
                ctx.fillStyle = '#f99';
                ctx.beginPath();
                for (const b of ebullets) {
                    ctx.moveTo(b.x, b.y);
                    ctx.arc(b.x, b.y, b.r, 0, TAU);
                }
                ctx.fill();

                // Enemies
                for (const e of enemies) {
                    drawEnemy(e);
                }

                // Pickups
                for (const p of pickups) {
                    drawPickup(p);
                }

                // Screen flash
                if (flash > 0) {
                    ctx.fillStyle = `rgba(255,255,255,${flash})`;
                    ctx.fillRect(0, 0, W, H);
                }

                // Overlays
                if (paused) {
                    drawText(W / 2, H * 0.45, 'PAUSED', 44);
                }
                if (!running && !gameOver) {
                    drawText(W / 2, H * 0.52, 'Press Start', 20);
                }
                if (gameOver) {
                    drawText(W / 2, H * 0.42, 'GAME OVER', 44);
                    drawText(W / 2, H * 0.54, 'Press R or click Start', 20);
                }
                if (waveAnnounce > 0) {
                    drawText(W / 2, H * 0.4, `Wave ${wave}`, 50, waveAnnounce);
                }
                if (comboShow > 0 && combo > 1) {
                    drawText(comboX, comboY - 20 - (1.2 - comboShow) * 30, `x${combo}`, 28, comboShow * 0.8, '#fde047', 'center', 'bottom');
                }
                if (upgradeState) {
                    drawText(W / 2, H * 0.3, 'Choose an Upgrade', 36);
                    const btnW = 200, btnH = 60;
                    const spacing = 1.1;
                    const startX = W / 2 - (btnW * 3 * spacing - btnW * (spacing - 1)) / 2;
                    const startY = H / 2 - btnH / 2;
                    for (let i = 0; i < 3; i++) {
                        const bx = startX + i * btnW * spacing;
                        const by = startY;
                        const t = upgradeNames[upgradeOptions[i]];
                        rounded(bx, by, btnW, btnH, 12, 'rgba(255,255,255,0.2)');
                        ctx.fillStyle = 'white';
                        ctx.font = '24px system-ui';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(t, bx + btnW / 2, by + btnH / 2);
                    }
                }

                // Reset transform
                ctx.setTransform(1, 0, 0, 1, 0, 0);
            }

            function drawGrid() {
                const cell = 40;
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let x = 0; x < W; x += cell) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, H);
                }
                for (let y = 0; y < H; y += cell) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(W, y);
                }
                ctx.stroke();
                const g = ctx.createRadialGradient(W / 2, H / 2, 0, W / 2, H / 2, Math.max(W, H) * 0.7);
                g.addColorStop(0, 'rgba(0,0,0,0)');
                g.addColorStop(1, 'rgba(0,0,0,0.65)');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, W, H);
            }

            function glow(x, y, r, col, alpha = 0.9) {
                const g = ctx.createRadialGradient(x, y, 0, x, y, r);
                g.addColorStop(0, col);
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.globalAlpha = alpha;
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, TAU);
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            function drawPlayer() {
                const x = player.x, y = player.y;
                glow(x, y, 26, 'rgba(103,232,249,0.25)', 1);
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(player.aim);
                rounded(-16, -12, 32, 24, 8, '#2d4266');
                ctx.fillStyle = '#9cc1ff';
                ctx.fillRect(0, -4, 18, 8);
                ctx.restore();
                const pct = clamp(player.hp / player.maxhp, 0, 1);
                ctx.strokeStyle = 'rgba(52,211,153,0.9)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(x, y, 22, -Math.PI / 2, -Math.PI / 2 + pct * TAU);
                ctx.stroke();
            }

            function rounded(x, y, w, h, r, col) {
                ctx.fillStyle = col;
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
                ctx.fill();
            }

            function drawEnemy(e) {
                let col = e.type === 'chaser' ? '#f59e0b' :
                          e.type === 'shooter' ? '#a78bfa' :
                          e.type === 'splitter' ? '#34d399' :
                          e.type === 'tank' ? '#fb7185' :
                          e.type === 'bomber' ? '#fde047' :
                          e.type === 'dasher' ? '#ec4899' :
                          '#e11d48';
                const baseR = e.r;
                glow(e.x, e.y, baseR + 2, e.type === 'shooter' || e.type === 'boss' ? 'rgba(167,139,250,0.35)' : 'rgba(255,255,255,0.2)', 1);
                if (e.type === 'dasher' && e.dashT > 0) {
                    glow(e.x, e.y, baseR + 8, 'rgba(236,72,153,0.4)', 0.8);
                }
                ctx.save();
                ctx.translate(e.x, e.y);
                ctx.scale(e.scale, e.scale);
                rounded(-baseR * 0.9, -baseR * 0.8, baseR * 1.8, baseR * 1.6, baseR * 0.4, '#22334f');
                ctx.fillStyle = col;
                ctx.fillRect(-baseR * 0.4, -baseR * 0.2, baseR * 0.8, baseR * 0.4);
                ctx.restore();
            }

            function drawPickup(p) {
                let col = p.t === 'heal' ? '#34d399' :
                          p.t === 'rate' ? '#67e8f9' :
                          p.t === 'dmg' ? '#fb7185' :
                          p.t === 'speed' ? '#fde047' :
                          p.t === 'shield' ? '#a78bfa' :
                          p.t === 'multi' ? '#f472b6' :
                          p.t === 'pierce' ? '#ec4899' :
                          p.t === 'homing' ? '#67e8f9' : '#ec4899';
                glow(p.x, p.y, 18, col.replace('1', '0.35'), 1);
                rounded(p.x - 8, p.y - 8, 16, 16, 6, col);
            }

            function drawText(x, y, text, size, alpha = 1, col = 'rgba(255,255,255,0.9)', align = 'center', base = 'middle') {
                ctx.font = `${size}px system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif`;
                ctx.fillStyle = col.replace('0.9', alpha.toString());
                ctx.textAlign = align;
                ctx.textBaseline = base;
                ctx.fillText(text, x, y);
            }

            // Start idle render & loop
            draw(0);
            requestAnimationFrame(loop);

            // Restart key
            window.addEventListener('keydown', e => {
                if (e.key === 'r' || e.key === 'R') {
                    if (!running) startGame();
                }
            });
        })();
        console.log('Kirubel Mesfin Production')
    </script>
</body>
</html>

